= キャプチャデバイス

本章では, 本稿で用いるキャプチャデバイスの実装や構成について紹介します.

== キャプチャデバイスの要件

コミケなどのイベント, 各種大規模なカンファレンス, 雑踏などの公衆の場といった人の多い環境を
ターゲットとするに当たっては以下の要件を満たせると運用が非常に楽です.

: 1. 携帯できる程度のコンパクトさ
  鞄の中に携行できる程度のサイズ, 重さであること. 何かのついでにキャプチャ&サーベイして回れることが
  理想なので鞄に忍ばせておいて...とできると手軽です. なにより怪しまれずに済むという利点もあります.
: 2. キャプチャ装置として自己完結すること
  ここでいう自己完結とは, 理想的にはキャプチャにまつわる全ての処理を
  それ自体で行えることを指します. さすがに解析や蓄積は性能やそれにともなって上がる値段およびスペースの点で
  困難である可能性がありますが, 最低限のキャプチャについての
  制御がそれ自体でできることが望ましいです.
  この要件にはそのための適切なインタフェースが備わっていることや,
  キャプチャを実施するのに必要なデバイスを駆動するための電源,
  正確なキャプチャを行うのに必要な時刻源が備わっていることなどが要件としてあります.
: 3. 6〜8時間程度のキャプチャが継続できること
  これは主に電源(バッテリー)が保つことを指しますが, より広義にはキャプチャデータの
  ストレージ容量がそれなりにあることも含みます.
: 4. あまり高くないこと
  10万を超えるなど, あまりにも高すぎる場合は手が出せなくなるので対象としません.
  また高いとコミケ等で人混みに揉まれたりといった環境に持ち込んで乱雑な扱いができなさそうなので,
  できるだけ安くかつすぐに調達が可能な部材での実装が望ましいです.

最低限キャプチャができるデバイスとしてこれまでは以下の様な組み合わせでどうにかしてきました.

: ノートPCの持ち歩き(Mac Book Air, Linux PC)
  airport/iwコマンドでチャネルを動かしつつ, Wiresharkまたはtsharkでキャプチャを実施することで
  それらしくキャプチャを行うことはできます. 問題としてはやはりそれなりに筐体が重いことと,
  それなりに大事なデバイスなのでコミケ等の押し合いになるような環境に持っていきづらいという点があります.
  また無線LAN機能をフルに駆動した場合にバッテリーの保ちがあまりよくなかっため実用的でないと判断しました.
  中・長時間の持ち歩きの必要がなく, 電源席のあるようなカンファレンス環境などではそれなりに有効ではあります.
: Nexus 7 + Android Pcap + USB Wi-Fi デバイス
  Android アプリで唯一 802.11フレームをキャプチャできるソフトとして Android Pcap があります. 
  Android 端末に USB OTP ケーブル + 対応のUSB Wi-Fi アダプタを挿せば使えるという手軽さのため導入しました.
  単に802.11フレームのキャプチャができるというだけでなくチャネルの遷移機能も付いており,
  無線LANのキャプチャをするということを分かった作りになっているところが大変良いです.
  実際に C86 の時に運用, キャプチャを行いました. 問題点としては, 対応デバイスが RTL8187@<fn>{rtl8187}に
  限られているという点があります. このデバイスは 2.4GHz 専用のため 5GHz 帯を扱えません.
  また Nexus 7 で運用したところ, それなりにUSBデバイスが電力を消費するためか実働で5時間が限界でした.
  特にUSB OTG ケーブルを挿していると充電ができないため, バッテリーが切れたらその時点でおしまいになってしまう点は不便です.
: ボードコンピュータ + モバイルバッテリー + USB Wi-Fi デバイス
  Raspberry Pi や Beagle Board, CubieBoardなどのボードコンピュータにモバイルバッテリーを接続,
  そこから給電することで自立駆動するLinux箱を用意し, その上でtsharkコマンドを用いてキャプチャを実施しました.
  インタフェースとして LEDチカチカもボタンも実装しなかったため, キャプチャの開始/停止等の制御は
  AndroidのシリアルコンソールアプリからUSBシリアルアダプタ経由で端末を叩くことで
  行っていました. 端末エミュレータがどれも微妙で大変に操作しづらいのに加えて, 制御時に
  シリアルケーブル用のピンヘッダを挿さないといけないので大分手間でした.
  また動作中は本当に動いているのか外見から判断が付かないうえに, 通常であれば手堅いはずの
  lsコマンドでのキャプチャデータの確認や ps コマンドでのキャプチャプロセスの確認なども
  困難という不便さがありました.

//footnote[rtl8187][なおRTL8187の載ったデバイスで日本の技術適合が通っている & 一般の人が使うようなデバイスはない模様]

== tochka

tochkaは前述のような試行錯誤を経て, 現在実運用に載せているものになります.
引き続きRaspberry Piをベースとしており, 外観としては@<img>{02-tochka-appearance}の様になっています.

//image[02-tochka-appearance][tochkaの機材外観]

これまでのデバイスとの変更点およびポイントは主に以下の4つです.

 1. PiTFTによるユーザインタフェース
 2. A5サイズの書類ケースに収まるサイズ
 3. 10時間程度の動作
 4．1万8千円程度のお値段

今回からはユーザインタフェースとして, PiTFTを載せています.
これによりキャプチャの制御と情報表示を単体で行うようにしましてた.
これまでは何かしようとする度に, シリアル変換アダプタを取り出したり
使いづらいターミナルでおっかなびっくり操作をしたり,
無言のRaspberry Piを大丈夫だと信じて運用して裏切られたりしてきました.
今回からはボタンをポチッとやるだけである程度どうにかなるようになっています.
画面上は@<img>{02-tochka-miniui-running_mono}のように表示されます.

//image[02-tochka-miniui-running_mono][tochkaのPiTFT画面(デモ用)]

サイズおよび重量についても個人的な許容範囲内に収められています.
仮で100円ショップのA5ファイルフォルダに詰めていますが,
W 242 mm, D 164 mm, H 40 mmで収まっており鞄の中にさっと忍ばせておけるようになっています.
重量としてもバッテリー込みで500g程度になっています.
タブレットより重く大きいですが, PCに比べると軽く
かつこれ以外に余計なものは必要ないのでその点は利点です.
またバッテリーをある程度大容量なものにすることで Wi-Fi USB デバイスを動かし
続けてもそれなりに単独で長時間動作するようになっています.

一番問題なのはお値段ですが, おおよそ1台あたり1万8千円程度になりました.
内訳については後述しますが, 本体・画面・バッテリーが70%程度を占めており
これらの単価がかなり響いています. とはいえ数万行く程度ではないので
よしとしておきましょう.


=== ユーザインタフェース

ハコとしてのtochkaは, バッテリーからの電源投入し起動後に制御用のUIを表示するようになっています.
画面上には以下の情報が表示されます.

: Date
  RTCまたはNTPから取得した現在時刻. RTCが正しく動作していることの確認用に表示しています.
: Host Name
  このtochkaデバイス(Raspberry Pi)に設定されたホスト名. 個体識別用に表示しています.
: State
  現在のキャプチャの状態. ボタン操作に応じて, @<em>{init}, @<em>{running}, @<em>{stop}, @<em>{unknown}の4状態を取ります.
: File Name
  キャプチャバックエンドが出力する pcapng ファイルの保存先ファイル名.
  "YYYYMMDDHHmmSS_${インタフェース名}_${PID}.pcapng"の形式を取ります.
  なおキャプチャデータは /cap ディレクトリに保存されます.
: File Size
  キャプチャしているpcapngのファイルサイズ.
: Duration
  キャプチャしている時間. 最後にキャプチャが開始されてからの経過時間を表示します.
: Current Channel
  現在当該インタフェースがモニタしているチャネル.
: Channel Walk
  チャネル遷移回数.
: Size per sec
  秒辺りのファイルサイズ増加速度. "File Size"を"Duration"で割ったもの.
  ストレージの減り予測用に表示しています.
: Utilization
  チャネルの使用率. 併記されているチャネルをモニタしていた際に取得た値を表示しています.
: Disk Usage
  Raspberry Piのルートパーティションのディスク使用量
: Memory Usage
  Raspberry Pi のメモリ使用量
: CPU Usage
  Raspberry Pi の CPU 使用率

PiTFT 自体はタッチ操作に対応していますが, tochka ではカーソルが動く以上の動作を実装していません.
制御にあたっては, PiTFT にパターンが実装されている4つのボタンを用います.
画面下部にガイドが表示されていますがそれぞれ @<em>{START}, @<em>{STOP}, @<em>{MODE1}, @<em>{MODE2} ボタンとなっており
以下の様な機能が割当たっています.

  * STARTボタン
  ** @<em>{init}または@<em>{stop}の場合: キャプチャの開始
  ** その他の場合: 無効
  * STOP
  ** stop count 0 の場合: 停止フェーズ 1 (stop countを1に設定)
  ** stop count 3 の場合: 最終停止 (キャプチャを停止)
  * MODE1
  ** stop count 0 の場合: 画面の消灯
  ** stop count 1 の場合: 停止フェーズ 2 (stop countを2に設定)
  * MODE 2
  ** stop count 2 の場合: 停止フェーズ 3 (stop countを3に設定)
  ** その他の場合: 画面の点灯

キャプチャは START ボタンを押すだけで開始されます.
動作中は MODE1, MODE2 でそれぞれ画面の消灯, 点灯を制御できます.
あまり省電力的な効果は期待してはいないのですが, 暗所や夜間でのキャプチャで
眩しかったり目障りだったり目立って弄られるのを避けるためにこの機能をつけています.
とあるクラブイベントに置いたときもこれを使って密かにキャプチャをしていました.

実際のキャプチャの停止は, 誤操作防止のため STOP ボタン一発にはしていません.
STOP, MODE1, MODE2, STOPと順に押すことで stop count を上げ, このパターンでのみ
止まるようになっています. 

#@# 将来的にはタッチ操作で複雑化させるといった方法をとる方が良いかとは思います.

=== ハードウェア構成

基本的な方針としてこれまでのプロトタイプを引き継いで Raspberry Pi ベースでの実装をしています.
これに加えて以下の様な点を取り込んでいます.

 * PiTFT, バッテリー, RTC, 3G/LTE (オプション)装備による自己完結性
 * 部材の共通化

部材としては @<table>{tochka_material} に記載されたもので構成されています.
これらを @<img>{02-hw-org} のように組み上げて利用しています.

//table[tochka_material][部材リスト]{
パーツ			名前			値段(概算)	備考
------------------------------------------------------------
筐体(本体)		Raspberry Pi 2 or B+	5100
画面			PiTFT 2.8inch		5000		ボタン 4つも必要
RTC			DS3231のもの		1000
バッテリー		cheero power plus 3	3500
SDカード		適当			1000		16GB程度あれば充分
USB Wi-Fi アダプタ	WI-U2-300D		2200		Monitorモード対応ならなんでも可
USBハブ			適当			1300		(オプショナル)ACアダプタ給電品
USB 3G デバイス		L-02C			2400		(オプショナル)中古品
SIM			Soracom SIM		900		(オプショナル)
ケーブル類		適当			1000		給電用USB micro B等
ケース			100円ショップのA5ケース	100		適当
//}

//image[02-hw-org][tochkaのハードウェア構成][scale=0.4]

時刻源としては RTC のモジュールを使用しています.
Raspberry Pi 自体のGPIOピンは PiTFT が埋めてしまいますが
PiTFTの裏側にGPIOピンが出ているためそこに接続します.
RTC利用時の注意点として, RTC付属のバッテリーの回復および時刻の更新が必要であるため
事前に充電およびNTP等のより正しい時刻源から同期をしておく必要があります.
風の噂ではRTCのバッテリーは一度充電すれば100日程度は保つようですが,
時刻のズレもでてくるため使用前には同期するのが望ましいでしょう.
なお, RTC はNTPで時刻が取得できない自立動作の場合に利用します.
USB 3G デバイスを接続し, インターネットに出られる場合はNTPを時刻源として用います.

#@# ここに写真

RTC以外の時刻源としてぱっと思いつくところでは GPSモジュール, 電波時計モジュール@<fn>{radio_clock},
ワンセグチューナー@<fn>{oneseg_clock}があげられます. GPSおよび電波時計は室内での利用に難があり,
例えばコミケのビッグサイト(特に室内)では両者ともに使えないまたは不安定なようです.
ワンセグは室内でもある程度利用ができ, 時刻源としても大変優秀とのことですが基本的にはUSBデバイスです.
後述する電源供給の都合上 USB デバイスを増やしすぎるのは問題であるため,
現在はもっとも手軽なRTCを選択しています.

//footnote[radio_clock][電波時計のキットはC86でもplus TK2S( http://plustk2s.sakura.ne.jp/wp/ )さんが販売していました]
//footnote[oneseg_clock][(ワンセグ)電波時計(の特性)http://hwhack.blogspot.jp/2008/02/blog-post_15.html]

キャプチャに用いる USB Wi-Fi アダプタとして WI-U2-300D を選択しました.
ただしこれに限らず, Monitorモードに入ることができ 2.4GHz帯と5GHz帯の双方で動作可能であり,
サポートしているチャネルが広ければ特に品を選びません. 考慮すべき点が他にあるとすれば
Raspberry Pi または Linux カーネルの本家にマージされているドライバを使う方が苦労が少なくてよいでしょう.
これまでは以下の様なデバイスを使ってきました. 

 * Buffalo WI-U2-300D (Ralink rt2800usb)
 * Buffalo WLI-UC-AG300N (Ralink rt2800usb)
 * NEC Aterm WL300NU-AG (Atheros carl9170)

チップ的にはRalink の rt2800usb および Atheros の carl9170 での利用実績がそれなりにあり,
後者はファームウェアのインストールのみ必要ですが, 両者とも raspbian および標準の
カーネルに導入されておりすぐに使えるため多用しています.
特に2.4GHzと5GHzに両対応で日本国内に出回っているものとしては上記の3つぐらいしか選択肢がありませんでした.
802.11ac対応のUSBデバイスについては今のところ未検証です.


USB ハブおよび USB 3G デバイスは第三章で述べる SORACOM SIM + fluentd を組み合わせて
キャプチャデータを直接当該デバイスから抽出, DBに流し込む際に使います.
単純なtochkaとしてのキャプチャを行う際には不要です.
#@# 3Gモデム自体あるいはそこ経由でNTPを使い時刻源として利用することも可能です.

 USB 3G デバイスを利用する際の注意点として Raspberry Pi のUSBポートの給電能力について考慮する必要があります.
Raspberry Pi からの 直接のUSB 給電では2つのデバイスを駆動できず, キャプチャか3Gのコネクションのいずれかが
不定期にハングするという問題が散見されています.このため, tochkaではモバイルバッテリーからUSBハブに対しても
給電を行うようにしています.なお, 現状のtochka ではUSB Wi-Fi アダプタ 2本挿しには対応していませんが,
この場合でも同様の電源対策が必要です. tochka ではAC電源から給電可能な口をもつUSB ハブとして Buffalo
の BSH4AE06 を用いています. 当該製品に給電するにあたり, USB Type-Aの口からDCコネクタに変換するケーブルを自作する必要があります.


=== ソフトウェア構成

大元の方針として述べたとおり, ソフトウェアのメインの仕事は単純にキャプチャを
し, ローカルストレージに溜め込むだけです.
手元のPC上で Wireshark/tshark/tcpdump を動かすのと特に大差はありません.
ただし手放しで無線LANのキャプチャをしてくれる箱としてはこれだけでは回りません.
このため以下の様な機能を併せて実装しています.

 * キャプチャ中に全チャネルのスイープ
 * PiTFTによる単独操作可能なユーザインタフェースの提供
 * チャネル使用率の記録

チャネルのスイープは, 2.4GHz帯および5GHz帯のそれぞれ個々のチャネル間を昇順に0.5秒おきに
遷移するようにしています. 2.4GHz帯では1から13までの13チャネルをサポートします.
5GHz帯については以下の28チャネルを対象としています. デバイスによっては後半のチャネルを
サポートしていないため, その部分はスキップするようにしています.

 * J52: 34, 38, 42, 46
 * W52: 36, 40, 44, 48
 * W53: 52, 56, 60, 64
 * W56: 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140
 * W58(U-NII-3): 149, 153, 157, 161, 165

PiTFTによるUI実装の導入は先に述べた通りです. 現状タッチ操作には対応していません.
garhvh/pitftmenu@<fn>{pitftmenu}のようにタッチでカッコイイ画面遷移/UIを作っている
人もいるので将来的に導入してみても良いかもしれません.

//footnote[pitftmenu][github.com/garthvh/pitftmenu]

チャネル使用率, として今回からチップが認識している active time と busy time の2つの
値を取得, 記録するようにしています. これらは iw survey dump コマンドの同名の値をベースとしています.
この値はそれぞれデバイス(チップ)が空間をモニタしていた時間, そのうちチップが802.11フレームの
受信やノイズの解消待ちでビジーだった時間を示しています. この2つの値は以下の図に指し示される
時間を表しています.

//image[02-utilization][active time と busy timeの関係][scale=0.5]

この値を取得することで, 当該チャネルの通信密度, 利用密度や空き状態の指標として使えると考えています.
tochkaでは@<list>{tochkad-util-log}にあるような文面でこれをログとして記録しています.
@<em>{utilization}は active time に占める busy time の割合であり, @<em>{uch} は当該情報が紐付くチャネルになります.

//list[tochkad-util-log][tochkadのログ出力例: iw survey dumpコマンドの結果]{
channel moved to 2 from 1 (dur=3434, size=270572536, walk=3197, utilization=80.35 uch=1)
channel moved to 3 from 2 (dur=3435, size=270596300, walk=3198, utilization=47.27 uch=2)
channel moved to 4 from 3 (dur=3437, size=270625516, walk=3199, utilization=32.84 uch=3)
channel moved to 5 from 4 (dur=3438, size=270642780, walk=3200, utilization=30.64 uch=4)
//}

なお,今回メインで用いている rt2800usb では activeと busy の2つの値しかとれませんが,
デバイスによってはさらに細かく rx, tx, busy, active の4つの値を取得することができます.
この場合はさらに, 受信か送信かノイズかといった区分が細かく分かるようになります.


ここまでに述べた各種機能を含む tochka のソフトウェアの構成は@<img>{02-sw-org}に記載されているようになっています.
大きく画面/UIを表示する tochka-miniui とキャプチャを実際に操作する tochkad に分かれています.
外部依存はキャプチャを行うのにtshark (wireshark), 画面の描画は SDL,
PiTFTの操作やボタン操作は wiringPI が必要となっています.

//image[02-sw-org][tochkaのソフトウェア構成]

#@# 削る
#@#==[column] (補) スペアナ(もどき)の併用について
#@#
#@#tochka の構成ではある程度エアタイムも取れるため, スペアナの利用を想定してはいません.
#@#前章でも述べた通り, 特に興味の対象が802.11のプロトコルレイヤに傾いているため
#@#スペアナの情報を収集してもあまり活用できないというのもその一因です.
#@#また第一章でも述べた通り, 基本的にお高いデバイスが多いため導入しづらいというのもあります.
#@#
#@#とはいえ併せて情報を貯めて時系列で見られると面白いというのもあり, どうにかできないかと
#@#試行錯誤をしています. さすがに WiSpy や SpeCatの導入はお財布的に厳しいので導入できませんが
#@#Hack RF One などの Software Defined Radio に類するデバイスを用いることで安価にでっちあげられそうではあります.
#@#
#@##@# ここにhackRFの写真
#@#
#@#単純には, tsharkでモニタしているチャネルと同一周波数帯をosmocom_spectrum_senseで観測するなど
#@#のフローを, エアタイム取得部分のロジックに組み込めばこれが可能となります.
#@#理想的には Beep Networks が公開している spectrum-map@<fn>{spectrum-map} のように
#@#イベント会場の無線LAN向け周波数帯の状況を時々刻々と残せると良さそうです.
#@#
#@#現状の問題点は, 電源や処理能力的に間に合うかという点と
#@#Hack RF One利用時にはosmocom_spectrum_senseで取得したデータの中心周波数付近に
#@#大きく不自然なピークが常に出てしまうという点です.
#@#この部分の是正が済めば導入にいたるかもしれません.
#@#
#@#//footnote[spectrum-map][http://spectrum-map.beepnetworks.com/]
